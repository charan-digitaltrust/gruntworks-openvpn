#!/usr/bin/env bash

set -e

readonly CA_PATH="/etc/openvpn-ca"
readonly OPENVPN_PATH="/etc/openvpn"
readonly DEFAULT_KEY_SIZE=4096
readonly DEFAULT_CA_EXPIRATION_DAYS=3650
readonly DEFAULT_CERT_EXPIRATION_DAYS=3650
readonly DEFAULT_CRL_EXPIRATION_DAYS=3650

function print_usage {
    echo
    echo "Usage: init-openvpn.sh [OPTIONS]"
    echo
    echo "Configure OpenVPN, Generate the PKI and backup to S3."
    echo
    echo "Options:"
    echo
    echo -e "  --locality\t\t\tThe locality name (e.g. city or town name) where your organization is located. Required."
    echo -e "  --state\t\t\tThe state or province name where your organization is located. Use the full, unabbreviated name. Required."
    echo -e "  --country\t\t\tThe two-letter country name where your organization is located (see https://www.digicert.com/ssl-certificate-country-codes.htm). Required."
    echo -e "  --org\t\t\t\tThe name of your organization (e.g. Gruntwork). Required."
    echo -e "  --org-unit\t\t\tThe name of the unit, department, or scope within your organization for which this CA certificate will be used. Required."
    echo -e "  --email\t\t\tThe e-mail address of the administrator."
    echo -e "  --s3-bucket-name\t\t\tThe name of the S3 bucket that will be created to backup PKI assets."
    echo -e "  --kms-key-id\t\t\tThe id of the KMS key that will be used to encrypt S3 assets."
    echo -e "  --key-size\t\t\tThe size of the DH keys (in bits). Defaults to 4096."
    echo -e "  --ca-expiration-days\t\t\tThe number of days the CA root certificate will be valid for. Defaults to 3650 (10 years)"
    echo -e "  --cert-expiration-days\t\t\tThe number of days the server and user certificates will be valid for. Defaults to 3650 (10 years)."
    echo -e "  --crl-expiration-days\t\t\tThe number of days the certificate revocation list will be valid for. Defaults to 3650 (10 years)."
    echo -e "  --vpn-subnet\t\t\tThe subnet the vpn clients will be assigned addresses from. Required. For example, 10.10.10.0 255.255.255.0"
    echo -e "  --vpn-route\t\t\tAdditional routes that will be pushed to the VPN clients and routed over the VPN. Can be specified multiple times. Required. For example, 10.200.0.0 255.255.255.0"
    echo
    echo "Example:"
    echo
    echo "  init-openvpn.sh \\"
    echo "    --locality \"Phoenix\" \\"
    echo "    --state \"Arizona\" \\"
    echo "    --country \"US\" \\"
    echo "    --org \"Gruntwork\" \\"
    echo "    --org-unit \"OpenVPN\" \\"
    echo "    --email \"support@gruntwork.io\" \\"
    echo "    --s3-bucket-name \"gruntwork-openvpn\" \\"
    echo "    --kms-key-id \"01533cb9-b46b-4380-b63e-54edf025d5d1\" \\"
    echo "    --vpn-subnet \"10.1.14.0 255.255.255.0\" \\"
    echo "    --vpn-route \"10.200.0.0 255.255.0.0\" "
}

# Assert that a given binary is installed on this box
function assert_is_installed {
    local readonly name="$1"

    if [[ ! $(command -v ${name}) ]]; then
        echo "ERROR: The binary '$name' is required by this script but is not installed or in the system's PATH."
        exit 1
    fi
}

# Assert that a command-line arg is not empty
function assert_not_empty {
    local readonly arg_name="$1"
    local readonly arg_value="$2"

    if [[ -z "$arg_value" ]]; then
        echo "ERROR: The value for '$arg_name' cannot be empty"
        print_usage
        exit 1
    fi
}

# Assert that the given string is of the given length
function assert_string_length {
    local readonly string_name="$1"
    local readonly string_value="$2"
    local readonly string_length_desired="$3"

    string_length_actual="${#string_value}"
    if [[ $string_length_actual != $string_length_desired ]]; then
        echo "ERROR: The string value for \"$string_name\" must be of length $string_length_desired, but \"$string_value\" is of length $string_length_actual."
        exit 1
    fi
}

# Assert that the script is running as root
function assert_uid_is_root_or_sudo {
    if [[ $EUID != 0 ]]; then
        echo "ERROR: This script should be run using sudo or as the root user"
        exit 1
    fi
}

function prep_config_dir {
    cd $CA_PATH
    source ./vars.local
    ./clean-all
}

function restore_vars_local_from_s3 {
    aws s3 cp s3://$1/server/vars.local $CA_PATH --sse "aws:kms" --sse-kms-key-id "$2"
}

# Restore the previously generated PKI assets from s3 so previously issued certificates continue to work
function restore_pki_assets_from_s3 {
    echo "Restore PKI assets from S3..."
    aws s3 cp s3://$1/server/ $OPENVPN_PATH --recursive --exclude "*" --include "*.crt" --sse "aws:kms" --sse-kms-key-id "$2"
    aws s3 cp s3://$1/server/ $OPENVPN_PATH --recursive --exclude "*" --include "*.key" --sse "aws:kms" --sse-kms-key-id "$2"
    aws s3 cp s3://$1/server/ $OPENVPN_PATH --recursive --exclude "*" --include "*.pem" --sse "aws:kms" --sse-kms-key-id "$2"
    aws s3 cp s3://$1/server/ $OPENVPN_PATH --recursive --exclude "*" --include "*.csr" --sse "aws:kms" --sse-kms-key-id "$2"
    aws s3 cp s3://$1/server/serial $OPENVPN_PATH --sse "aws:kms" --sse-kms-key-id "$2"
    aws s3 cp s3://$1/server/serial.old $OPENVPN_PATH --sse "aws:kms" --sse-kms-key-id "$2"
    aws s3 cp s3://$1/server/index.txt $OPENVPN_PATH --sse "aws:kms" --sse-kms-key-id "$2"
    aws s3 cp s3://$1/server/index.txt.old $OPENVPN_PATH --sse "aws:kms" --sse-kms-key-id "$2"
    aws s3 cp s3://$1/server/index.txt.attr $OPENVPN_PATH --sse "aws:kms" --sse-kms-key-id "$2"
}

function copy_config_templates {
    echo "Copying OpenVPN config teamplates into place..."
    cp /gruntwork/install-openvpn/openvpn-client.ovpn $OPENVPN_PATH/
}

function generate_server_conf {
    local vpnSubnet="$1"
    local routes="$2"
    local keySize="$3"
    local dnsServer=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2}')

    cat << EOF > $OPENVPN_PATH/server.conf
##
## This is a configuration file for the OpenVPN Server.
##
##

port 1194
proto udp
dev tun
ca ca.crt
cert server.crt
key server.key  # This file should be kept secret
dh dh$keySize.pem
topology subnet
crl-verify /etc/openvpn/crl.pem
persist-key
persist-tun
server $vpnSubnet
ifconfig-pool-persist ipp.txt

# Certain Windows-specific network settings
# can be pushed to clients, such as DNS
# or WINS server addresses.
push "dhcp-option DNS $dnsServer"

keepalive 10 120
cipher AES-256-CBC
auth SHA256
user  nobody
group nogroup
$routes

verb 4
daemon
mute 20

EOF
}

#Takes a subnet mask (255.255.255.0) and returns network portion bit length (24)
function mask2CIDR {
    local nbits=0
    local IFS=.
    for dec in $1 ; do
        case $dec in
            255) let nbits+=8;;
            254) let nbits+=7;;
            252) let nbits+=6;;
            248) let nbits+=5;;
            240) let nbits+=4;;
            224) let nbits+=3;;
            192) let nbits+=2;;
            128) let nbits+=1;;
            0);;
            *) echo "Error: $dec is not a valid netmask"; exit 1
        esac
    done
    echo "$nbits"
}

#Takes network portion bit length (24) and returns subnet mask (255.255.255.0)
function cidr2mask {
   local i mask=""
   local full_octets=$(($1/8))
   local partial_octet=$(($1%8))

   for ((i=0;i<4;i+=1)); do
    if [ $i -lt $full_octets ]; then
      mask+=255
    elif [ $i -eq $full_octets ]; then
      mask+=$((256 - 2**(8-$partial_octet)))
    else
      mask+=0
    fi
    test $i -lt 3 && mask+=.
  done

  echo $mask
}

function extractMask {
    local ipArray=($1)
    local mask=${ipArray[1]}
    echo $mask
}

function extractSubnet {
    local ipArray=($1)
    local subnet=${ipArray[0]}
    echo $subnet
}

function configure_tcpip {
    echo "Configure TCP/IP settings..."
    local subnet=$(extractSubnet "$1")
    local mask=$(extractMask "$1")
    local cidr=$(mask2CIDR $mask)
    local subnet_cidr="$subnet/$cidr"
    cp /gruntwork/install-openvpn/ufw-default /etc/default/ufw
    sed "s~__VPN_SUBNET__~$subnet_cidr~g;" /gruntwork/install-openvpn/before.rules > /etc/ufw/before.rules

    # Enable TCP forwarding
    sysctl -w net.ipv4.ip_forward=1

    #Add Firewall Rules
    ufw allow 1194/udp
    ufw allow OpenSSH
    iptables-save

    ufw disable
    ufw --force enable
}

function is_pki_bootstrapped {
    local count
    count=$(aws s3 ls $1/server/ca.key | wc -l)
    [[ "$count" -gt 0 ]]
}

function generate_easy_rsa_variables_file {
    echo "Generating EASY_RSA variables file..."
    [[ -d "$CA_PATH" ]] || make-cadir $CA_PATH
    sed "s~__KEY_COUNTRY__~$1~g; s~__KEY_PROVINCE__~$2~g; s~__KEY_CITY__~$3~g; s~__KEY_ORG__~$4~g; s~__KEY_EMAIL__~$5~g; s~__KEY_OU__~$6~g; s~__KEY_NAME__~$7~g; s~__KEY_SIZE__~$8~g; s~__CA_EXPIRE__~$9~g; s~__KEY_EXPIRE__~${10}~g;" /gruntwork/install-openvpn/vars.local >"$CA_PATH/vars.local"
}

function update_default_crl_days {
    echo "Updating default_crl_days in $CA_PATH/openssl-1.0.0.cnf"
    sed -i 's/^default_crl_days=.*/default_crl_days= $1/' $CA_PATH/openssl-1.0.0.cnf
}

#generate and revoke a dummy certificate to init certificate revocation list (crl)
function generate_and_revoke_dummy_certificate {
    cd $CA_PATH
    ./build-key --batch dummy
    ./revoke-full dummy || true
}

function generate_pki {
    echo "Generating new PKI assets [this will take a long time]..."
    #Build the CA
    ./build-ca --batch

    #Generate and sign the server certificate
    ./build-key-server --batch server

    #Build strong Diffie-Hellman params for use during key exchange. This takes a LONG time (10+ minutes)
    ./build-dh

    #generate an HMAC signature to strengthen the server's TLS integrity verification capabilities
    openvpn --genkey --secret $OPENVPN_PATH/ta.key

    generate_and_revoke_dummy_certificate
}

# Once all of the PKI assets have been generated, upload them to s3 for backup purposes
function backup_pki_assets_to_s3 {
    echo "Backing up new PKI assets to S3..."
    aws s3 cp /etc/openvpn s3://$1/server/ --recursive --sse "aws:kms" --sse-kms-key-id "$2"
    aws s3 cp $CA_PATH/vars.local s3://$1/server/vars.local --sse "aws:kms" --sse-kms-key-id "$2"
}

function change_config_dir_permissions {
    echo "Setting $OPENVPN_PATH owenership and permissions..."
    chown -R nobody:nogroup $OPENVPN_PATH
    chmod -R 770 $OPENVPN_PATH
}

function start_openvpn {
    echo "Starting OpenVPN..."
    systemctl enable openvpn@server
    systemctl restart openvpn@server
}

function init_openvpn {
    local key_size="$DEFAULT_KEY_SIZE"
    local ca_expiration_days="$DEFAULT_CA_EXPIRATION_DAYS"
    local cert_expiration_days="$DEFAULT_CERT_EXPIRATION_DAYS"
    local crl_expiration_days="$DEFAULT_CRL_EXPIRATION_DAYS"

    local locality=""
    local state=""
    local country=""
    local org=""
    local org_unit=""
    local email=""
    local access_key=""
    local access_secret=""
    local bucket_name=""
    local kms_key_id=""
    local region=""
    local vpn_subnet=""
    local routes=( )

    while [[ $# -gt 0 ]]; do
        local key="$1"

        case "$key" in
            --locality)
                locality="$2"
                shift
                ;;
            --state)
                state="$2"
                shift
                ;;
            --country)
                country="$2"
                shift
                ;;
            --org)
                org="$2"
                shift
                ;;
            --org-unit)
                org_unit="$2"
                shift
                ;;
            --email)
                email="$2"
                shift
                ;;
            --s3-bucket-name)
                bucket_name=$2
                shift
                ;;
            --kms-key-id)
                kms_key_id=$2
                shift
                ;;
            --key-size)
                key_size=$2
                shift
                ;;
            --ca-expiration-days)
                ca_expiration_days=$2
                shift
                ;;
            --cert-expiration-days)
                cert_expiration_days=$2
                shift
                ;;
            --crl-expiration-days)
                crl_expiration_days=$2
                shift
                ;;
            --vpn-subnet)
                vpn_subnet=$2
                shift
                ;;
            --vpn-route)
                routes=("${routes[@]}" "$2")
                shift
                ;;
            --help)
                print_usage
                exit
                ;;
            *)
                echo "ERROR: Unrecognized argument: $key"
                print_usage
                exit 1
                ;;
        esac

        shift
    done

    assert_not_empty "--locality" "$locality"
    assert_not_empty "--state" "$state"
    assert_not_empty "--country" "$country"
    assert_string_length "--country" "$country" 2
    assert_not_empty "--org" "$org"
    assert_not_empty "--org-unit" "$org_unit"
    assert_not_empty "--email" "$email"
    assert_not_empty "--s3-bucket-name" "$bucket_name"
    assert_not_empty "--kms-key-id" "$kms_key_id"
    assert_not_empty " --key-size" "$key_size"
    assert_not_empty "--ca-expiration-days" "$ca_expiration_days"
    assert_not_empty "--cert-expiration-days" "$cert_expiration_days"
    assert_not_empty "--crl-expiration-days" "$crl_expiration_days"
    assert_not_empty "--vpn-route" "$routes"
    assert_not_empty "--vpn-subnet" "$vpn_subnet"

    #Pre-Reqs
    assert_uid_is_root_or_sudo
    assert_is_installed aws
    assert_is_installed openssl

    if $(is_pki_bootstrapped "$bucket_name"); then
        restore_vars_local_from_s3 "$bucket_name" "$kms_key_id"
        prep_config_dir
        restore_pki_assets_from_s3 "$bucket_name" "$kms_key_id"
    else
        generate_easy_rsa_variables_file "$country" "$state" "$locality" "$org" "$email" "$org_unit" "server" "$key_size" "$ca_expiration_days" "$cert_expiration_days"
        prep_config_dir
        generate_pki
        backup_pki_assets_to_s3 "$bucket_name" "$kms_key_id"
    fi

    update_default_crl_days "$crl_expiration_days"

    local routesStr=""
    for i in "${routes[@]}"
    do
        routesStr=$(printf "$routesStr\npush \"route $i\"")
    done

    copy_config_templates
    generate_server_conf "$vpn_subnet" "$routesStr" "$key_size"
    change_config_dir_permissions
    configure_tcpip "$vpn_subnet"
    start_openvpn

    echo "Success!"
}

init_openvpn "$@"
